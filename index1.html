<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript_full_1</title>
    <link rel="stylesheet" href="style1.css" />
  </head>

  <body>
    <!-- 1. How does JavaScript works? -->
    <div>
      <h2>1. How does JavaScript works?</h2>
      <p>
        1.1 JavaScript is an interpreted language, which means that it is not
        compiled into machine code before it is executed. This makes JavaScript
        slower than compiled languages, but it also makes it more flexible and
        easier to debug.
      </p>
      <p>
        1.2 JavaScript is a dynamically typed language, which means that the
        type of a variable is not declared explicitly. This can make JavaScript
        code more error-prone, but it also makes it more concise.
      </p>
      <p>
        1.3 JavaScript is a single-threaded language, which means that only one
        piece of JavaScript code can be executed at a time. This can make
        JavaScript code less responsive, but it also makes it easier to write
        correct code.
      </p>
      <p>
        <strong>STEP 1: PARSER</strong> <br />
        This is the first stage of the engine, every time we run a JavaScript
        program, our code is first received by the "parser" inside the JS
        engine. The parser's job is to check the JavaScript code for syntactic
        errors in line by line manner because JavaScript is an interpretive
        scripting language, so whenever an error is detected by the parser, it
        throws a kind of error and stops execution of the code.
      </p>
      <p>
        <strong>STEP 2: AST</strong> <br />
        Once the parser checks all javascript codes and gets satisfied that
        there are no mistakes/errors in the code, it creates the data structure
        called AST (Abstract Syntax Tree).
      </p>
      <p>
        <strong>STEP 3: CONVERSION TO MACHINE CODE</strong> <br />
        Once the Abstract Syntax Tree is created by the parser, the JavaScript
        engine converts the JavaScript code into the machine code (or in the
        language that machine can understand).
      </p>
      <p>
        <strong>STEP 4: MACHINE CODE</strong> <br />
        When the program written in the JavaScript gets converted in the machine
        language (or in the byte code), the converted code is sent to the system
        for execution, and finally, that byte code run by the system / engine.
      </p>
      <hr />
    </div>
    <!-- 2. Is JavaScript a Synchronous or Asynchronous programming language? -->
    <div>
      <h2>
        2. Is JavaScript a Synchronous or Asynchronous programming language?
      </h2>
      <p>
        2.1 JavaScript is a programming language that supports both synchronous
        and asynchronous behavior. By default, JavaScript is single-threaded and
        synchronous, meaning that code execution occurs in a sequential and
        blocking manner. However, JavaScript also provides mechanisms to handle
        asynchronous operations efficiently.
      </p>
      <p>
        2.2 So, while JavaScript is primarily synchronous, it offers mechanisms
        like callbacks, Promises, and async/await to handle asynchronous
        operations effectively and avoid blocking the execution of other code.
      </p>
      <p>
        2.3 Here is an example of synchronous code: <br />
        function foo() { <br />
        // Do something that takes a long time <br />
        var result = 1000; <br />
        // Do something else <br />
        console.log(result); <br />
        } <br />
        This code will print the number 1000, but the user will have to wait for
        the long-running task to complete before they can see the output.
      </p>
      <p>
        2.4 Here is an example of asynchronous code: <br />
        function foo() { <br />
        // Do something that takes a long time <br />
        var result = 1000; <br />
        // Return a promise that will be resolved when the task is complete
        return new Promise(function(resolve, reject) { <br />
        // Do something else <br />
        console.log(result); <br />
        // Resolve the promise when the task is complete <br />
        resolve(result); <br />
        }); <br />
        } <br />
        This code will also print the number 1000, but the user will not have to
        wait for the long-running task to complete before they can see the
        output. This is because the code that prints the result is executed
        asynchronously.
      </p>
      <hr />
    </div>
    <!-- 3. How does JavaScript executes code? -->
    <div>
      <h2>3. How does JavaScript executes code?</h2>
      <p>
        3.1 JavaScript code is executed by an engine, which is a program that
        interprets and executes JavaScript instructions. The most widely used
        JavaScript engine is the V8 engine, developed by Google, which powers
        popular web browsers like Chrome and Node.js. The execution process of
        JavaScript code involves several steps:
      </p>
      <p>
        <strong>STEP 1: TOKENIZATION / LEXICAL ANALYSIS:</strong><br />
        The engine breaks down the source code into individual tokens, such as
        keywords, identifiers, operators, and literals. This step is known as
        tokenization or lexical analysis.
      </p>
      <p>
        <strong>STEP 2: PARSING / SYNTAX ANALYSIS:</strong><br />
        The engine parses the tokens and constructs an Abstract Syntax Tree
        (AST), representing the syntactic of the code. This step is known as
        parsing or syntax analysis.
      </p>
      <p>
        <strong>STEP 3: COMPILATION</strong><br />
        The engine compiles the AST into executable code. Initially, the
        compilation might involve generating an intermediate representation of
        the code (such as bytecode) or optimizing the code for better
        performance. Some engines also utilize Just-In-Time (JIT) compilation
        techniques to further optimize the code.
      </p>
      <p>
        <strong>STEP 4: EXECUTION</strong><br />
        The compiled code is executed by the engine. The engine starts executing
        the code from the entry point, typically the first line of the script.
        It follows the control flow of the program, executing statements one by
        one. Functions and blocks of code are executed when they are encountered
        during the program's execution.
      </p>
      <p>
        3.2 During the execution process, the engine also manages various
        components, such as the execution context and the call stack:
      </p>
      <p>
        <strong>EXECUTION CONTEXT: </strong><br />
        An execution context is an environment where JavaScript code is
        executed. It consists of variables, function declarations, the value of
        'this', and other relevant information. Every time a function is called,
        a new execution context is created, forming a stack-like structure known
        as the execution context stack.
      </p>
      <p>
        <strong>CALL STACK: </strong><br />
        The call stack is a data structure used by the JavaScript engine to keep
        track of the currently executing functions. It follows the
        Last-In-First-Out (LIFO) principle, meaning that the most recently
        executed invoked function is always at the top of the stack. When a
        function is called, a new execution context is created and pushed onto
        the call stack. The JavaScript engine starts executing the statements
        within the function's execution context.
      </p>
      <p>
        If the function calls other functions, their execution contexts are also
        pushed onto the stack, forming a stack frame for each function.
      </p>
      <p>
        If the function completes its execution, its execution context is popped
        off the call stack, and the control returns to the context of the
        previous function.
      </p>
      <p>
        This process continues until the call stack is empty, indicating that
        all functions have finished executing. The call stack ensures that
        function calls are executed in the order they are made and provides a
        mechanism for managing the flow of execution and maintaining the correct
        order of function contexts.
      </p>
      <p>
        3.3 By managing the execution context and the call stack, the JavaScript
        engine can keep track of the state of function execution, handle
        variable scope and access, and ensure that functions are executed in the
        correct order.
      </p>
      <hr />
    </div>
    <!-- 4. What is Temporal Dead Zone? -->
    <div>
      <h2>4. What is Temporal Dead Zone?</h2>
      <p>
        4.1 Temporal Dead Zone (TDZ) is a behavior in JavaScript that occurs
        when accessing variables declared with 'let' and 'const' before they are
        initialized. The TDZ concept was introduced in ECMAScript 2015 (ES6) as
        part of the block-scoping mechanism.
      </p>
      <p>
        4.2 In javascript, when a variable is declared using 'let' or 'const'
        inside a block (such as a function or a pair of curly braces), the
        variable is hoisted to the top of the block but remains uninitialized
        until the declaration statement is encountered during runtime.
      </p>
      <p>
        4.3 However, during the TDZ, attempting to access the variable before
        its initialization will result in a runtime error.
      </p>
      <p>
        4.4 The purpose of TDZ is to prevent accidental hoisting and making the
        code more readable and maintainable. It is important to note that the
        TDZ applies only to variables declared with 'let' and 'const', not to
        variable declared with 'var'. Variables declared with 'var' are hoisted
        to the top of their containing function or global scope, allowing them
        to be accessed before their declaration.
      </p>
      <hr />
    </div>
    <!-- 5. async vs defer attribute -->
    <div>
      <h2>5. async vs defer attribute</h2>
      <p>
        5.1 The async and defer attributes are used to load JavaScript files
        asynchronously, without blocking the rendering of the page. However,
        there are some key differences between the two attributes.
      </p>
      <p>
        5.2 Async: Scripts with the async attribute are executed as soon as they
        are loaded, in no particular order. This means that the order of
        execution of async scripts is not guaranteed, and they may execute
        before or after scripts on the page.
      </p>
      <p>
        5.3 Defer: Scripts with the defer attribute are executed after the page
        has finished loading, in the order in which they appear in the HTML.
        This means that the order of execution of defer scripts is guaranteed,
        but they will not block the rendering of the page.
      </p>
      <p>
        5.4 However, there are some cases where defer may be a better option.
        For Example, if you have a script that needs to access the DOM, you
        should use defer to ensure that the DOM is fully loaded before the
        script is executed.
      </p>
      <hr />
    </div>
    <!-- 6. Difference between textContent, innerText and innerHTML -->
    <div>
      <h2>6. Difference between textContent, innerText and innerHTML</h2>
      <p>
        6.1 The textContent, innerText and innerHTML properties in JavaScript
        are used to get or set the text content of an element and its
        descendants. However, there are some key differences between them.
      </p>
      <p>
        6.2 textContent returns the text content of an element, including any
        whitespace and formatting characters. It does not include any HTML tags.
      </p>
      <p>
        6.3 innerText is similar to textContent, but it does not include any
        whitespace and formatting characters. This means that the text content
        of an element will be returned as a single, unbroken string.
      </p>
      <p>
        6.4 innerHTML returns the HTML content of an element, including all HTML
        tags. This means that the text content of an element, as well as any
        HTML tags that are associated with it, will be returned.
      </p>
      <hr />
    </div>
    <!-- 7. getAttribute() vs setAttribute() -->
    <div>
      <h2>7. getAttribute() vs setAttribute()</h2>
      <p>
        7.1 The getAttribute() and setAttribute() methods are used to get and
        set attributes of an HTML element in JavaScript.
      </p>
      <p>
        7.2 getAttribute() gets the value of an attribute of an HTML element.
        The syntax is element.getAttribute(name), where name is the name of the
        attribute. For Example, to get the value of the href attribute of an a
        element, you would use the following code:
      </p>
      <p>var href = document.querySelector('a').getAttribute('href');</p>
      <p>
        7.3 setAttribute() sets the value of an attribute of an HTML element.
        The syntax is element.setAttribute(name, value), where name is the name
        of the attribute and value is the new value of the attribute. For
        Example, to set the value of the href attribute of an a element to
        https://www.google.com, you would use the following code:
      </p>
      <p>
        document.querySelector('a').setAttribute('href',
        'https://www.google.com');
      </p>
      <hr />
    </div>
    <!-- 8. getElementsByTagName() vs getElementsByClassName() -->
    <div>
      <h2>8. getElementsByTagName() vs getElementsByClassName()</h2>
      <p>
        8.1 The getElementsByTagName() and getElementsByClass() methods are used
        to select elements in the DOM by their tag name and class name,
        respectively.
      </p>
      <p>
        8.2 getElementsByTagName() returns a collection of all elements with the
        specified tag name. The syntax is
        document.getElementsByTagName(tagName), where tagName is the name of the
        tag. For Example, to get all the p elements in the document, you would
        use the following code:
      </p>
      <p>let pElements = document.getElementsByTagName('p');</p>
      <p>
        8.3 getElementsByClassName() returns a collection of all elements with
        the specified class name. The syntax is
        document.getELementsByClassName(className), where className is the name
        of the class. For Example, to get all the elements with the class name
        "example", you would use the following code:
      </p>
      <p>let exampleElements = document.getElementsByClassName("example");</p>
      <hr />
    </div>
    <!-- 9. Array.from() -->
    <div>
      <h2>9. Array.from()</h2>
      <p>
        9.1 The Array.from() method in JavaScript is a static method that
        creates a new array from an iterable or array-like object. The iterable
        can be anything that can iterated over, such as an array, a string, or a
        list. The array-like object is an object that has a length property and
        indexed elements.
      </p>
      <p>9.2 Array.from(iterable[, mapFn[, thisArg]])</p>
      <p>9.3 It is a concise way to create new arrays.</p>
      <p>
        9.4 It is a powerful way to create new arrays from a variety of sources.
      </p>
      <p>9.5 It is a consistent way to create new arrays.</p>
      <hr />
    </div>
    <!-- 10. When to use appendChild() and innerHTML? -->
    <div>
      <h2>10. When to use appendChild() and innerHTML?</h2>
      <p>
        10.1 innerHTMl and appendChild() are both methods used to manipulate the
        DOM (Document Object Model) in JavaScript. However, they have different
        purposes and should be used in different situations.
      </p>
      <p>
        10.2 innerHTML is used to set the inner HTML of an element. This means
        that it can be used to replace the existing content of an element with
        new HTMl. For Example, the following code would replace the content of
        the div element with a new p element:
      </p>
      <p>
        const div = document.querySelector('div');
        <br />
        div.innerHTMl = 'p This is new content /p';
      </p>
      <p>
        10.3 appendChild() is used to append a new node to the end of a parent
        node. This means that it can be used to add new elements to the DOM. For
        example, the following code would append a new p element to the end of
        the div element:
      </p>
      <p>
        const div = document.querySelector('div');
        <br />
        const p = document.createElement('p');
        <br />
        p.innerHTML = 'This is new content';
        <br />
        div.appendChild(p);
      </p>
      <p>
        10.4 When to use innerHTML -
        <br />
        10.4.1 When you need to replace the existing content of an element with
        new HTMl.
        <br />
        10.4.2 When you need to insert dynamic content into the DOM.
        <br />
        10.4.3 When you need to perform a complex manipulation of the DOM that
        would be difficult or inefficient to do with appendChild().
      </p>
      <p>
        10.5 When to use appendChild() -
        <br />
        10.5.1 When you need to add a new element to the DOM.
        <br />
        10.5.2 When you need to maintain the existing structure of the DOM.
        <br />
        10.5.3 When you need to perform a simple manipulation of the DOM that
        can be done more efficiently with appendChild() than with innerHTML.
      </p>
      <p>
        10.6 In general, appendChild() is the preferred method for manipulating
        the DOM. However, innerHTML can be useful in some situations.
      </p>
      <hr />
    </div>

    <script src="script1.js"></script>
  </body>
</html>
