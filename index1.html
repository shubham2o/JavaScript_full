<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript_full_1</title>
    <link rel="stylesheet" href="style1.css" />
  </head>

  <body>
    <!-- 1. How does JavaScript works? -->
    <div>
      <h2>1. How does JavaScript works?</h2>
      <p>
        1.1 JavaScript is an interpreted language, which means that it is not
        compiled into machine code before it is executed. This makes JavaScript
        slower than compiled languages, but it also makes it more flexible and
        easier to debug.
      </p>
      <p>
        1.2 JavaScript is a dynamically typed language, which means that the
        type of a variable is not declared explicitly. This can make JavaScript
        code more error-prone, but it also makes it more concise.
      </p>
      <p>
        1.3 JavaScript is a single-threaded language, which means that only one
        piece of JavaScript code can be executed at a time. This can make
        JavaScript code less responsive, but it also makes it easier to write
        correct code.
      </p>
      <p>
        <strong>STEP 1: PARSER</strong> <br />
        This is the first stage of the engine, every time we run a JavaScript
        program, our code is first received by the "parser" inside the JS
        engine. The parser's job is to check the JavaScript code for syntactic
        errors in line by line manner because JavaScript is an interpretive
        scripting language, so whenever an error is detected by the parser, it
        throws a kind of error and stops execution of the code.
      </p>
      <p>
        <strong>STEP 2: AST</strong> <br />
        Once the parser checks all javascript codes and gets satisfied that
        there are no mistakes/errors in the code, it creates the data structure
        called AST (Abstract Syntax Tree).
      </p>
      <p>
        <strong>STEP 3: CONVERSION TO MACHINE CODE</strong> <br />
        Once the Abstract Syntax Tree is created by the parser, the JavaScript
        engine converts the JavaScript code into the machine code (or in the
        language that machine can understand).
      </p>
      <p>
        <strong>STEP 4: MACHINE CODE</strong> <br />
        When the program written in the JavaScript gets converted in the machine
        language (or in the byte code), the converted code is sent to the system
        for execution, and finally, that byte code run by the system / engine.
      </p>
      <hr />
    </div>
    <!-- 2. Is JavaScript a Synchronous or Asynchronous programming language? -->
    <div>
      <h2>
        2. Is JavaScript a Synchronous or Asynchronous programming language?
      </h2>
      <p>
        2.1 JavaScript is a programming language that supports both synchronous
        and asynchronous behavior. By default, JavaScript is single-threaded and
        synchronous, meaning that code execution occurs in a sequential and
        blocking manner. However, JavaScript also provides mechanisms to handle
        asynchronous operations efficiently.
      </p>
      <p>
        2.2 So, while JavaScript is primarily synchronous, it offers mechanisms
        like callbacks, Promises, and async/await to handle asynchronous
        operations effectively and avoid blocking the execution of other code.
      </p>
      <p>
        2.3 Here is an example of synchronous code: <br />
        function foo() { <br />
        // Do something that takes a long time <br />
        var result = 1000; <br />
        // Do something else <br />
        console.log(result); <br />
        } <br />
        This code will print the number 1000, but the user will have to wait for
        the long-running task to complete before they can see the output.
      </p>
      <p>
        2.4 Here is an example of asynchronous code: <br />
        function foo() { <br />
        // Do something that takes a long time <br />
        var result = 1000; <br />
        // Return a promise that will be resolved when the task is complete
        return new Promise(function(resolve, reject) { <br />
        // Do something else <br />
        console.log(result); <br />
        // Resolve the promise when the task is complete <br />
        resolve(result); <br />
        }); <br />
        } <br />
        This code will also print the number 1000, but the user will not have to
        wait for the long-running task to complete before they can see the
        output. This is because the code that prints the result is executed
        asynchronously.
      </p>
      <hr />
    </div>
    <!-- 3. How does JavaScript executes code? -->
    <div>
      <h2>3. How does JavaScript executes code?</h2>
      <p>
        3.1 JavaScript code is executed by an engine, which is a program that
        interprets and executes JavaScript instructions. The most widely used
        JavaScript engine is the V8 engine, developed by Google, which powers
        popular web browsers like Chrome and Node.js. The execution process of
        JavaScript code involves several steps:
      </p>
      <p>
        <strong>STEP 1: TOKENIZATION / LEXICAL ANALYSIS:</strong><br />
        The engine breaks down the source code into individual tokens, such as
        keywords, identifiers, operators, and literals. This step is known as
        tokenization or lexical analysis.
      </p>
      <p>
        <strong>STEP 2: PARSING / SYNTAX ANALYSIS:</strong><br />
        The engine parses the tokens and constructs an Abstract Syntax Tree
        (AST), representing the syntactic of the code. This step is known as
        parsing or syntax analysis.
      </p>
      <p>
        <strong>STEP 3: COMPILATION</strong><br />
        The engine compiles the AST into executable code. Initially, the
        compilation might involve generating an intermediate representation of
        the code (such as bytecode) or optimizing the code for better
        performance. Some engines also utilize Just-In-Time (JIT) compilation
        techniques to further optimize the code.
      </p>
      <p>
        <strong>STEP 4: EXECUTION</strong><br />
        The compiled code is executed by the engine. The engine starts executing
        the code from the entry point, typically the first line of the script.
        It follows the control flow of the program, executing statements one by
        one. Functions and blocks of code are executed when they are encountered
        during the program's execution.
      </p>
      <p>
        3.2 During the execution process, the engine also manages various
        components, such as the execution context and the call stack:
      </p>
      <p>
        <strong>EXECUTION CONTEXT: </strong><br />
        An execution context is an environment where JavaScript code is
        executed. It consists of variables, function declarations, the value of
        'this', and other relevant information. Every time a function is called,
        a new execution context is created, forming a stack-like structure known
        as the execution context stack.
      </p>
      <p>
        <strong>CALL STACK: </strong><br />
        The call stack is a data structure used by the JavaScript engine to keep
        track of the currently executing functions. It follows the
        Last-In-First-Out (LIFO) principle, meaning that the most recently
        executed invoked function is always at the top of the stack. When a
        function is called, a new execution context is created and pushed onto
        the call stack. The JavaScript engine starts executing the statements
        within the function's execution context.
      </p>
      <p>
        If the function calls other functions, their execution contexts are also
        pushed onto the stack, forming a stack frame for each function.
      </p>
      <p>
        If the function completes its execution, its execution context is popped
        off the call stack, and the control returns to the context of the
        previous function.
      </p>
      <p>
        This process continues until the call stack is empty, indicating that
        all functions have finished executing. The call stack ensures that
        function calls are executed in the order they are made and provides a
        mechanism for managing the flow of execution and maintaining the correct
        order of function contexts.
      </p>
      <p>
        3.3 By managing the execution context and the call stack, the JavaScript
        engine can keep track of the state of function execution, handle
        variable scope and access, and ensure that functions are executed in the
        correct order.
      </p>
      <hr />
    </div>
    <!-- 4. What is Temporal Dead Zone? -->
    <div>
      <h2>4. What is Temporal Dead Zone?</h2>
      <p>
        4.1 Temporal Dead Zone (TDZ) is a behavior in JavaScript that occurs
        when accessing variables declared with 'let' and 'const' before they are
        initialized. The TDZ concept was introduced in ECMAScript 2015 (ES6) as
        part of the block-scoping mechanism.
      </p>
      <p>
        4.2 In javascript, when a variable is declared using 'let' or 'const'
        inside a block (such as a function or a pair of curly braces), the
        variable is hoisted to the top of the block but remains uninitialized
        until the declaration statement is encountered during runtime.
      </p>
      <p>
        4.3 However, during the TDZ, attempting to access the variable before
        its initialization will result in a runtime error.
      </p>
      <p>
        4.4 The purpose of TDZ is to prevent accidental hoisting and making the
        code more readable and maintainable. It is important to note that the
        TDZ applies only to variables declared with 'let' and 'const', not to
        variable declared with 'var'. Variables declared with 'var' are hoisted
        to the top of their containing function or global scope, allowing them
        to be accessed before their declaration.
      </p>
      <hr />
    </div>
    <!-- 5. async vs defer attribute -->
    <div>
      <h2>5. async vs defer attribute</h2>
      <p>
        5.1 The async and defer attributes are used to load JavaScript files
        asynchronously, without blocking the rendering of the page. However,
        there are some key differences between the two attributes.
      </p>
      <p>
        5.2 Async: Scripts with the async attribute are executed as soon as they
        are loaded, in no particular order. This means that the order of
        execution of async scripts is not guaranteed, and they may execute
        before or after scripts on the page.
      </p>
      <p>
        5.3 Defer: Scripts with the defer attribute are executed after the page
        has finished loading, in the order in which they appear in the HTML.
        This means that the order of execution of defer scripts is guaranteed,
        but they will not block the rendering of the page.
      </p>
      <p>
        5.4 However, there are some cases where defer may be a better option.
        For Example, if you have a script that needs to access the DOM, you
        should use defer to ensure that the DOM is fully loaded before the
        script is executed.
      </p>
      <hr />
    </div>

    <script src="script1.js"></script>
  </body>
</html>
